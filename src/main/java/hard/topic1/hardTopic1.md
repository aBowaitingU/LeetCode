# 寻找两个有序数组的中位数

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

## 示例 1:

nums1 = [1, 3]

nums2 = [2]

则中位数是 2.0
## 示例 2:

nums1 = [1, 2]

nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5


## 思路：

### 递归法

在统计中，中位数被用来：

将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。

首先，让我们在任一位置 i 将 A 划分成两个部分：

          left_A             |        right_A
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
由于 A 中有 m 个元素， 所以我们有 m+1 种划分的方法（i = 0∼m）。

采用同样的方式，我们在任一位置 j 将 B 划分成两个部分：

          left_B             |        right_B
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
将 left_A 和 left_B 放入一个集合，并将 right_A 和 right_B 放入另一个集合。 再把这两个新的集合分别命名为 left_part 和 right_part：

          left_part          |        right_part
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
如果我们可以确认：

1.len(left_part) = len(right_part)

2.max(left_part) <= min(right_part)

那么，我们已经将 {A,B} 中的所有元素划分为相同长度的两个部分，且其中一部分中的元素总是大于另一部分中的元素。

median=(max(left_part)+min(right_part))/2

只需要：

1.i+j=m−i+n−j（或：m - i + n - j + 1） 如果 n >= m，只需要使 i = 0 ~ m, j = (m + n + 1)/2 - i

2.B[j-1] <= A[i] 以及 A[i-1] <= B[j]


本题的具体解法可以参考官方题解

​