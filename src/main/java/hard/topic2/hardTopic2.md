# 正则表达式匹配

给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。

**说明**:

s 可能为空，且只包含从 a-z 的小写字母。

p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
## 示例 1:

输入:

s = "aa"

p = "a"

输出: false

解释: "a" 无法匹配 "aa" 整个字符串。
## 示例 2:

输入:

s = "aa"

p = "a*"

输出: true

解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
## 示例 3:

输入:

s = "ab"

p = ".*"

输出: true

解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
## 示例 4:

输入:

s = "aab"

p = "c*a*b"

输出: true

解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
## 示例 5:

输入:

s = "mississippi"

p = "mis*is*p*."

输出: false

## 解法
没做出来，写的时候越写越复杂，写到后面发现最开始的有的地方还是有问题（我也很绝望啊）。看了下别人写的代码，根据代码写了下解法。
### 动态规划法
我们用s[0, i]和p[0, j]来分别表示字符串s和字符串p的被截取后左边部分的子串。s[0, 0]和p[0, 0]表示空字符串，
s[0, slen],p[0, plen]表示字符串s和p（slen和plen分别表示s和p的长度）。

我们使用动态规划，动态分析s和p的左半子串s[o, i]和p[0, j]是否匹配。

记match（x, y）表示为s[0, x]是否被p[0, y]所匹配，匹配为t，否则为f。

对于s[0, 0]和p[0, 0]，两个子串均为空字符串，p[0, 0]匹配s[0, 0]，即match(0, 0) = t;

对于s[0, i],判定s[0, i]是否被p[0, j]所匹配，有两种情况：
1. 当p[j - 1] != '*'时。此时，p[j - 1]需要满足 p[j - 1] == s[i - 1] || p[j - 1] ==  '.',
同时，s[0, i - 1]要被p[0, j - 1]所匹配。另外，当i=0时，即s[0, i]为空字符串，此时不可能被p[0, j]所匹配。即
   > match(i, j) = i > 0 && match(i - 1, j - 1) && (p[j - 1] == s[i - 1] || p[j - 1] ==  '.')
2. 当p[j - 1] == '*'时。此时，p[j - 2]这个字符可能存在0个至多个。此时我们也分两类讨论：
   1. 当p[j - 2]这个字符存在0个时。要使match(i, j)成立，当且仅当match(i, j - 2)成立，即
      > match(i , j) = match(i, j - 2)
   2. 当p[j - 2]这个字符存在1个及1个以上时。此时p[j - 2]需要满足 p[j - 2] == s[i - 1] || p[j - 2] == '.',
   同时，s[0, i - 1]需要被p[0, j]所匹配。同理，i=0，s为空字符串时，match不可能成立。即
      > match(i, j) = i > 0 && match(i - 1, j) && ( p[j - 2] == s[i - 1] || p[j - 2] == '.')

   综上
   > match(i, j) = match(i, j - 2) || (i > 0 && match(i - 1, j) && ( p[j - 2] == s[i - 1] || p[j - 2] == '.'))

最后，match(slen, plen)即为我们想要的结果。

ps：

对于边缘的match(0, j)和match(i, 0)的值（i > 0, j > 0）。match(0, j)只能由情况2的i判定，只有p[0, j]为重复的"k*"格式，match(0, j)才能为t；
match(i, 0)则必为f，因为s[0, i]非空而p[0, 0]为空。

### 子模式匹配
emmmmm，暂时不想看代码，先挖个坑
