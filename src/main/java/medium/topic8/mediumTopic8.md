# 三数之和
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
## 解法
### 借助map的解法（时间效率不高）
首先，我们需要建立输入数组nums的值与其在输入数组的位置index的列表的映射Map<Integer, List<Integer>> map。

然后，我们取输入数组中的两个值nums[i]与nums[j]，j > i。则我们需要的第三个值num = 0 - nums[i] - nums[j]。
我们通过map判断num是否在数组中，如果存在，则[nums[i], nums[j], num]为符合要求的一个解。

然鹅，这道题目并不是这么简单。题目要求，解集中不能存在重复的解。这需要我们进行一系列的判定。考虑到我们建立的map，
数值的位置index列表是按照从小到大的顺序排列的。对可行解[num[i], num[j], num]我们增加以下几点约束：
1. 如果在值num的indexList中，存在index < j,则此num值之前已被加入到解集中，本次可行解被舍弃
2. 对于值nums[i]，其位置索引index如果不在其的indexList的0号索引位，则说明值nums[i]已经不是第一次取得，本次可行解被舍弃
3. 对于值nums[j]。当nums[i] != nums[j]，同第2点，j必须在nums[j]的indexList的0号索引位；
    当nums[i] == nums[j]时，j必须在indexList的第1号索引位（第0号为i）。

最初也考虑过借助set的不重复性来实现解集的去重复。但是当输入的数据量很大时，会大大降低效率。（本来这做法效率也不高） 

### 我也不知道该怎么取名字反正效率就是很高的解法
看了一下提交记录中效率最高的方法，研究了一下（具体可以看我在里面做的注释）

首先，将nums中的值num在nums中重复出现的次数的存入相应位置的数组map中。同时建立两个数组poses和negs，
分别存放输入数组中消去重复的正值和负值，且按照从小到大的顺序排序。

然后，我们从大到小从负数数组negs中取一个负数nv，则满足条件的另外两个数必定分布在(-nv) / 2的两侧。
我们从正数数组poses中取出所有大于（-nv） / 2的值pv，再计算出满足条件的第三的数cv = 0 - nv - pv。
查阅数组map，若cv在输入数组nums中有出现，则[nv, pv, cv]为一个可行解。

去除重复性。我们要求，cv要在[nv, pv]的范围内，当cv = nv或pv时，还要求该值在数组map中出现的次数大于1。
cv必定会小于等于pv，而当cv小于nv时，随着nv的取值越来越小，后续的迭代还会重复到该中情形，所以我们舍弃cv < nv的情况。


